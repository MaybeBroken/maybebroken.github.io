<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Basic 3D Platformer Game</title>
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            overflow: hidden;
        }

        body {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-family: sans-serif;
            z-index: 10;
        }

        #UI_ROOT {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #background_menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('https://cdn.cloudflare.steamstatic.com/steam/apps/2204810/ss_fcfdcbfdf60e41c715fc6bd2c7d25e1bc9c43f92.1920x1080.jpg');
            transform: scale(1.15);
        }

        #start_overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 1);
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5em;
            font-family: sans-serif;
            z-index: 1000;
            cursor: none;
            user-select: none;
        }

        body.hide-cursor,
        #start_overlay {
            cursor: none !important;
        }
    </style>
</head>


<body>
    <div id="info">The Backrooms | Programmed by MaybeBroken</div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
    <div id="UI_ROOT">
        <div id="background_menu" class="background_menu"></div>
        <div id="player_menu_model" class="player_menu_model"></div>
        <div id="game_menu"
            style="position: absolute; z-index: 1100; top: 0; left: 0; width: 100vw; height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; display: none;">
            <div style="color: #fff; font-size: 2.5em; margin-bottom: 1em; text-shadow: 0 2px 8px #000;">The Backrooms
            </div>
            <button id="start_button"
                style="font-size: 1.5em; padding: 0.5em 2em; border-radius: 8px; border: none; background: #fff; color: #222; cursor: pointer; box-shadow: 0 2px 8px #000;">Start</button>
        </div>
    </div>
    <div id="start_overlay" style="display:flex;">Press anywhere to begin</div>
</body>

<script>
    // Await user input: show overlay, then menu, then fullscreen/pointer lock, then start game
    function awaitUserInputAndStart() {
        const overlay = document.getElementById('start_overlay');
        const gameMenu = document.getElementById('game_menu');
        const startButton = document.getElementById('start_button');
        const backgroundMenu = document.getElementById('background_menu');

        // Parallax effect for menu
        let menuParallaxX = 0, menuParallaxY = 0;
        function updateMenuParallax(x, y) {
            backgroundMenu.style.backgroundPosition = `calc(50% + ${x}px) calc(50% + ${y}px)`;
        }
        function handleMenuParallax(e) {
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            menuParallaxX = (e.clientX - centerX) * -.15;
            menuParallaxY = (e.clientY - centerY) * -.15;
            updateMenuParallax(menuParallaxX, menuParallaxY);
        }
        // Set initial background position to center for menu
        menuParallaxX = 0;
        menuParallaxY = 0;
        updateMenuParallax(menuParallaxX, menuParallaxY);
        document.addEventListener('mousemove', handleMenuParallax);

        function requestFullscreen() {
            if (document.body.requestFullscreen) {
                return document.body.requestFullscreen();
            } else if (document.body.webkitRequestFullscreen) {
                return document.body.webkitRequestFullscreen();
            } else if (document.body.mozRequestFullScreen) {
                return document.body.mozRequestFullScreen();
            } else if (document.body.msRequestFullscreen) {
                return document.body.msRequestFullscreen();
            }
            return Promise.resolve();
        }

        function requestPointerLock() {
            if (document.body.requestPointerLock) {
                document.body.requestPointerLock();
            } else if (document.body.mozRequestPointerLock) {
                document.body.mozRequestPointerLock();
            }
        }

        async function showMenuAfterOverlay() {
            overlay.style.display = 'none';
            // Request fullscreen as soon as overlay is destroyed (user gesture)
            try { await requestFullscreen(); } catch (e) { }
            gameMenu.style.display = 'flex';
            overlay.removeEventListener('mousedown', showMenuAfterOverlay);
            overlay.removeEventListener('touchstart', showMenuAfterOverlay);
        }

        overlay.addEventListener('mousedown', showMenuAfterOverlay);
        overlay.addEventListener('touchstart', showMenuAfterOverlay);

        async function startGameSequence() {
            gameMenu.style.display = 'none';
            // Fade out background_menu
            const backgroundMenu = document.getElementById('background_menu');
            backgroundMenu.style.transition = 'opacity 0.7s';
            backgroundMenu.style.opacity = '0';
            // Remove menu parallax event when game starts
            document.removeEventListener('mousemove', handleMenuParallax);
            // Hide mouse cursor and request pointer lock only when game starts
            document.body.classList.add('hide-cursor');
            requestPointerLock();
            // Wait for fade out before starting game
            setTimeout(setupGame, 700);
        }

        startButton.addEventListener('click', startGameSequence);
    }

    function setupGame() {

        // Ensure cursor stays hidden for the whole game
        document.body.classList.add('hide-cursor');
        window.addEventListener('mousedown', () => {
            document.body.classList.add('hide-cursor');
        });
        window.addEventListener('touchstart', () => {
            document.body.classList.add('hide-cursor');
        });

        const backgroundMenu = document.getElementById('background_menu');

        // Parallax effect
        let parallaxX = 0, parallaxY = 0;

        function updateBackgroundParallax(x, y) {
            backgroundMenu.style.backgroundPosition = `calc(50% + ${x}px) calc(50% + ${y}px)`;
        }

        function handleBackgroundParallax(e) {
            // If pointer is locked, ignore this event (handled by mousemove)
            if (document.pointerLockElement === document.body) return;
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            parallaxX = (e.clientX - centerX) * -.15;
            parallaxY = (e.clientY - centerY) * -.15;
            updateBackgroundParallax(parallaxX, parallaxY);
        }

        function handlePointerLockMove(e) {
            // Only update if pointer is locked
            if (document.pointerLockElement !== document.body) return;
            // e.movementX/Y are relative deltas
            parallaxX += e.movementX * -.15;
            parallaxY += e.movementY * -.15;
            updateBackgroundParallax(parallaxX, parallaxY);
        }

        // Set initial background position to center
        parallaxX = 0;
        parallaxY = 0;
        updateBackgroundParallax(parallaxX, parallaxY);

        document.addEventListener('mousemove', handleBackgroundParallax);
        document.addEventListener('pointerlockchange', () => {
            // Optionally reset parallax when pointer lock is lost
            if (document.pointerLockElement !== document.body) {
                // Optionally clamp or reset parallaxX/parallaxY here if needed
            }
        });
        // Listen for mousemove events for pointer lock
        document.addEventListener('mousemove', handlePointerLockMove);

        function rgbToHex(r, g, b) {
            return (r << 16) | (g << 8) | b;
        }
        function hexToRgb(hex) {
            return {
                r: (hex >> 16) & 0xff,
                g: (hex >> 8) & 0xff,
                b: hex & 0xff
            };
        }
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(rgbToHex(0.5, 0.5, 0.5));

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set(0, 2, 5);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 10, 7);
        light.castShadow = true;
        light.shadow.mapSize.width = 4096;
        light.shadow.mapSize.height = 4096;
        light.shadow.camera.near = 1;
        light.shadow.camera.far = 50;
        light.shadow.camera.left = -20;
        light.shadow.camera.right = 20;
        light.shadow.camera.top = 20;
        light.shadow.camera.bottom = -20;
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        // Optionally, for debugging:
        // scene.add(new THREE.CameraHelper(light.shadow.camera));

        const keys = {};
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        scene.fog = new THREE.FogExp2(0x000000, 0.01);
        // Create a 2D floor (large, flat box)
        const floorGeometry = new THREE.BoxGeometry(50, 0.2, 50);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x888866, emissive: 0x999999, emissiveIntensity: 0.5 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.position.y = 0; // Slightly below y=0
        floor.castShadow = false;
        floor.receiveShadow = true;
        scene.add(floor);

        camera.position.y = 1.8;
        // Use a playerCam object for all camera movement and rotation
        const playerCam = new THREE.Object3D();
        const cameraPitch = new THREE.Object3D();
        playerCam.add(cameraPitch);
        cameraPitch.add(camera);
        scene.add(playerCam);

        // Set initial position
        playerCam.position.set(0, 1.8, 5);
        camera.position.set(0, 0, 0);
        cameraPitch.rotation.x = 0;

        // Track pitch/yaw angles
        let yaw = 0;
        let pitch = 0;

        // Player mesh
        const playerGeometry = new THREE.BoxGeometry(0.5, 1.8, 0.5);
        const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
        const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
        playerMesh.position.set(0, 1.8, 0);
        playerMesh.castShadow = true;
        playerMesh.receiveShadow = true;
        // Place player mesh in the world, not as a child of playerCam
        scene.add(playerMesh);

        // Jump state
        let jumping = false;
        let jumpStartY = 1.5;
        let jumpTargetY = 2.5;
        let jumpProgress = 0;
        const jumpDuration = 0.25; // seconds
        let lastTime = performance.now();

        document.addEventListener('mousemove', function rotateCamera(e) {
            if (document.pointerLockElement !== document.body) return;
            yaw -= e.movementX * 0.002;
            pitch -= e.movementY * 0.002;
            // Clamp pitch
            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
            playerCam.rotation.y = yaw;
            cameraPitch.rotation.x = pitch;
        });

        // Game loop
        function animate() {
            requestAnimationFrame(animate);
            let now = performance.now();
            let delta = (now - lastTime) / 1000;
            lastTime = now;

            // Handle player movement (move playerCam, which holds the camera)
            let moveSpeed = 0.16;
            let forward = new THREE.Vector3(0, 0, -1).applyQuaternion(playerCam.quaternion);
            let right = new THREE.Vector3(1, 0, 0).applyQuaternion(playerCam.quaternion);
            forward.y = 0;
            right.y = 0;
            forward.normalize();
            right.normalize();

            if (keys['KeyW']) playerCam.position.add(forward.clone().multiplyScalar(moveSpeed));
            if (keys['KeyS']) playerCam.position.add(forward.clone().multiplyScalar(-moveSpeed));
            if (keys['KeyA']) playerCam.position.add(right.clone().multiplyScalar(-moveSpeed));
            if (keys['KeyD']) playerCam.position.add(right.clone().multiplyScalar(moveSpeed));
            if (keys['KeyQ']) playerCam.rotation.y -= 0.01;
            if (keys['KeyE']) playerCam.rotation.y += 0.01;

            // Crouch logic (cannot crouch while jumping)
            if (!jumping) {
                if (keys['ShiftLeft']) {
                    playerCam.position.y = 1.0;
                } else if (playerCam.position.y < 1.5) {
                    playerCam.position.y += 0.1;
                    if (playerCam.position.y > 1.5) playerCam.position.y = 1.5;
                }
            }

            // Jump logic (lerp)
            if (keys['Space'] && !jumping && playerCam.position.y >= 1.49) {
                jumping = true;
                jumpStartY = playerCam.position.y;
                jumpTargetY = jumpStartY + 1.0;
                jumpProgress = 0;
            }
            if (jumping) {
                jumpProgress += delta / jumpDuration;
                if (jumpProgress >= 1) {
                    jumpProgress = 1;
                    jumping = false;
                }
                // Lerp up, then let gravity pull down
                playerCam.position.y = jumpStartY + (jumpTargetY - jumpStartY) * easeOutQuad(jumpProgress);
            } else {
                // Handle gravity
                if (playerCam.position.y > (keys['ShiftLeft'] ? 1.0 : 1.5)) {
                    playerCam.position.y -= 0.05;
                    if (playerCam.position.y < (keys['ShiftLeft'] ? 1.0 : 1.5)) playerCam.position.y = (keys['ShiftLeft'] ? 1.0 : 1.5);
                }
            }
            // Handle floor collision
            if (playerCam.position.y < (keys['ShiftLeft'] ? 1.0 : 1.5)) {
                playerCam.position.y = (keys['ShiftLeft'] ? 1.0 : 1.5);
                jumping = false;
            }
            // Make the light follow the player
            light.position.set(
                playerCam.position.x + 5,
                playerCam.position.y + 10,
                playerCam.position.z + 7
            );
            light.target.position.set(
                playerCam.position.x,
                playerCam.position.y,
                playerCam.position.z
            );
            scene.add(light.target);

            // Update player mesh position to match playerCam (but offset so you can see it)
            playerMesh.position.set(
                playerCam.position.x,
                playerCam.position.y - 0.9, // center of mesh at feet
                playerCam.position.z
            );
            renderer.render(scene, camera);
        }

        // Easing function for jump (ease out)
        function easeOutQuad(t) {
            return t * (2 - t);
        }

        animate();
    }

    // Start the process after DOM is ready
    window.addEventListener('DOMContentLoaded', awaitUserInputAndStart);

    const NPC_ARR = [];
    class NPC {
        constructor() {
            this.geometry = new THREE.BoxGeometry(0.5, 1.8, 0.5);
            this.material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
            this.mesh = new THREE.Mesh(this.geometry, this.material);
            this.mesh.position.set(Math.random() * 10 - 5, 1.8, Math.random() * 10 - 5);
            this.mesh.castShadow = true;
            this.mesh.receiveShadow = true;
        }
    }

    class MULTIPlAYER {
        constructor() {
            this.geometry = new THREE.BoxGeometry(0.5, 1.8, 0.5);
            this.material = new THREE.MeshStandardMaterial({ color: 0x0000ff });
            this.mesh = new THREE.Mesh(this.geometry, this.material);
            this.mesh.position.set(Math.random() * 10 - 5, 1.8, Math.random() * 10 - 5);
            this.inventory = [];
        }
    }

    function createNPC() {
        const npc = new NPC();
        scene.add(npc.mesh);
        NPC_ARR.push(npc);
    }
</script>

</html>